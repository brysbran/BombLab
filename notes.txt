phase 1
----------------------
-used objdump and it was out in the open

phase 2
----------------------
- fibonacci sequence, calls recursively to compare if the given int is correct


phase 3 notes
-----------------------
- first number must be greater than length 2
	testing used 3, which is greater than length 2
	-(gdb) p /x $eax
		$1 = 0x3
-expecting char for 2nd piece
 	- skips char for 2nd case but comes back to it at the end
 	- char is stored in %al, which is least sig byte of %rax
 	- when call x/1d $al gives 0x76, which converting from hex
  	  to char is "v"
-expecting number for 3rd piece
 	- 866

phase 4
----------------------

- firstly by searching "x/s 0x5555555572ef" returns "%d %d" given by one of the comments
out to the side this tells me the answer format is "int int"
- the first "cmp" compares if there are two given ints and if so, it falls
though the bomb call to the next comparison
- at +31 we compare 0x2 to %eax, and jump to +43 if 0x2 is not equal to %eax
- at +36 we have 0xE (14) being compared to what's 12 bytes beyond %rsp, which is 1.
	- this jumps (JBE == jump if below or equal) to +48 when the input ints are 1 and 2.
----------------
Inside Funct4()
----------------
- Up to line +10, registers %rax, $rcx, %rdx all contain 14
- At +10, %ecx is getting shifted right by 32
- +13 that value in %eax(14) is getting added to %ecx (0)
- +15 ecx gets shifted arithmetic right once
- +17 %esi is added to %ecx rsulting in 7 in %ecx
- +19 compare %edi(=1) and %ecx(=7), then jumps to +35 if edi is greater than ecx
- +35 subtracts 1 from edx making it 6.
- 
                                                                                                                                                                                                                                     
- after a funct 4 is called later on in the phase, the vlaue in %eax is compared to 7.
	- if not 7, bomb is called
- then if  8 bytes past %rsp is 7, we are done


#################
# GENERAL NOTES #
#################

- to find value in register with an offset, "x/1d $rsp+12" for "0xc(%rsp)



